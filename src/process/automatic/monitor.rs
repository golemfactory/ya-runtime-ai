use super::*;

use reqwest::Client;
use std::sync::Arc;
use std::time::Duration;
use tokio::sync::oneshot::{self};
use tokio::task::JoinHandle;
use tokio_stream::StreamExt;

static _API_PING_DELAY: Duration = Duration::from_millis(997);

static _STARTUP_MSG: &str = "Model loaded in ";

static _MODEL_LOAD_FAILURE_MSG: &str = "Stable diffusion model failed to load";

const _LOG_MESSAGES_W_TRACE_LVL: [&str; 1] = [
    // log generated by API ping task
    "\"GET / HTTP/1.1\" 404 Not Found",
];

pub(super) struct OutputMonitor {
    #[allow(dead_code)]
    output_task: Arc<JoinHandle<()>>,
    #[allow(dead_code)]
    pinger_task: Arc<JoinHandle<()>>,
}

impl OutputMonitor {
    pub async fn start(lines: OutputLines) -> anyhow::Result<Self> {
        let (on_startup_tx, on_startup_rx) = oneshot::channel();
        let output_handler = OutputHandler::LookingForStartup { on_startup_tx };
        let output_task = Arc::new(spawn_output_monitoring(lines, output_handler));
        // Repetitive calling Automatic API triggers flushing Automatic process `stdout`.
        let pinger_task = Arc::new(spawn_api_pinger());

        on_startup_rx
            .await
            .context("Monitoring Automatic startup failed")??;

        Ok(Self {
            output_task,
            pinger_task,
        })
    }
}

fn spawn_output_monitoring(
    mut lines: OutputLines,
    mut output_handler: OutputHandler,
) -> JoinHandle<()> {
    tokio::spawn(async move {
        while let Some(line) = lines.next().await {
            match line {
                Ok(line) => {
                    output_handler = output_handler.handle(line);
                }
                Err(err) => log::error!("Failed to read line. Err {err}"),
            }
        }
    })
}

/// Repetitive calling Automatic API triggers flushing process `stdout`.
/// It is required to log it, to monitor Automatic startup, and its shutdown.
/// When Automatic is started from console its output gets flushed.
/// Description and solution idea for faced issue https://stackoverflow.com/a/39528785/2608409
fn spawn_api_pinger() -> JoinHandle<()> {
    log::debug!("Starting API pinger");
    let client = Client::new().get(format!("http://{_API_HOST}:{_API_PORT}"));
    tokio::spawn(async move {
        loop {
            let Some(client) = client.try_clone() else {
                log::error!("Unable ping API");
                break;
            };
            log::trace!("Pinging API");
            match client.send().await {
                Ok(response) => log::trace!("Ping respone: {response:?}"),
                Err(err) => log::warn!("Ping failure: {err:?}"),
            };
            tokio::time::sleep(_API_PING_DELAY).await;
        }
    })
}

enum OutputHandler {
    LookingForStartup {
        //TODO create a custom error type?
        on_startup_tx: oneshot::Sender<anyhow::Result<()>>,
    },
    Logging,
}

impl OutputHandler {
    fn handle(self, line: String) -> Self {
        log_process_output(&line);
        match self {
            Self::LookingForStartup { on_startup_tx } => {
                if line.starts_with(_STARTUP_MSG) {
                    if on_startup_tx.send(Ok(())).is_err() {
                        log::error!("Failed to notify on startup");
                    }
                    return Self::Logging;
                } else if line.starts_with(_MODEL_LOAD_FAILURE_MSG) {
                    if on_startup_tx
                        .send(Err(anyhow::anyhow!("Automatic failed to load model")))
                        .is_err()
                    {
                        log::error!("Failed to notify on model loading failure");
                    }
                    log::warn!("Failed to load model");
                    return Self::Logging;
                }
                Self::LookingForStartup { on_startup_tx }
            }
            Self::Logging => self,
        }
    }
}

fn log_process_output(line: &str) {
    for message in _LOG_MESSAGES_W_TRACE_LVL {
        if line.contains(message) {
            log::trace!("> {line}");
            return;
        }
    }
    log::debug!("> {line}");
}
